---
title: "Misc / LunaDBv2 - HolaCTF 2025"
excerpt: "A writeup on the Misc / LunaDBv2 challenge from HolaCTF 2025"
category:
  - "CTF"
  - "Writeups"
tags:
  - "CTF"
  - "Misc"
  - "2025"
languages:
    - vi
authors:
    - "harshfeudal"
---

*LunaDB* 

*108 pts*

*x1x_* 

*I got a dumped database file from LUNA Co., but I‚Äôm unable to read its contents. All I‚Äôve got is the database creator‚Äôs source code. This‚Äôll be a cracking challenge, won‚Äôt it?*

B√†i n√†y th√¨ d·ªÖ, c√°c b·∫°n c√≥ th·ªÉ b·ªè v√†o GPT cho n√≥ gi·∫£i. Ho·∫∑c t·ª± gi·∫£i. Nh∆∞ m√¨nh th√¨ m√¨nh s·∫Ω b·ªè v√†o chatGPT cho l·∫π.

Trong file `main.rs` th√¨ c√°c b·∫°n c√≥ th·ªÉ th·∫•y ƒë∆∞·ª£c c√°c y·∫øu t·ªë sau ƒë√¢y:

```rust
const H_START: [u8; 4] = hex!("FF1337FF");
const H_END:   [u8; 4] = hex!("FFCAFEFF");
const D_START:   [u8; 4] = hex!("FF7270FF");
const D_END:     [u8; 4] = hex!("FFEDEDFF");
const F_START: [u8; 4] = hex!("FFDEADFF");
const F_END:   [u8; 4] = hex!("FFBEEFFF");
const SIG:    [u8; 4] = hex!("4C554E41"); 
```

M·ªói **note** trong ph·∫ßn d·ªØ li·ªáu g·ªìm:

- ID, username, email, title, v.v.
- M·ªôt **key mask** (u64) ‚Üí cho bi·∫øt note n√†y d√πng key n√†o ƒë·ªÉ m√£ ho√°
- D·ªØ li·ªáu ƒë√£ m√£ ho√°
- Timestamp v√† tr·∫°ng th√°i

Trong `fn encrypt(key: &[u8;8], plaintext: &[u8])` :

```rust
fn encrypt(key: &[u8;8], plaintext: &[u8]) -> Result<Vec<u8>, String> {
    let cipher = Cipher::des_ecb();
    let mut crypter = Crypter::new(cipher, Mode::Encrypt, key, None)
        .map_err(|e| format!("Something wrong... {}", e))?;
    crypter.pad(true);
    let mut out = vec![0; plaintext.len() + cipher.block_size()];
    let mut len = crypter.update(plaintext, &mut out)
        .map_err(|e| format!("Something wrong... {}", e))?;
    len += crypter.finalize(&mut out[len..])
        .map_err(|e| format!("Something wrong... {}", e))?;
    out.truncate(len);
    Ok(out)
}
```

c√°c b·∫°n s·∫Ω th·∫•y c√≥ `Cipher::des_ecb()` v√† c·∫£ `crypter.pad(true)`, nghƒ©a l√† **DES ECB mode**, c√≥ padding PKCS#7

M·ªü `secret.lunadb` trong hex editor ‚Üí th·∫•y c√°c marker (`FF 13 37 FF`, `FF DE AD FF`, ‚Ä¶).

Trong ph·∫ßn `F_START...F_END` l√† nhi·ªÅu key DES li√™n ti·∫øp, m·ªói c√°i d√†i 8 byte.

Trong ph·∫ßn `D_START...D_END` l√† c√°c note. M·ªói note c√≥:

- M·ªôt key mask (d·∫°ng bitmask) ‚Üí th·ª±c ch·∫•t ch·ªâ b·∫≠t **m·ªôt bit duy nh·∫•t**, n√™n m·ªói note ch·ªâ d√πng ƒë√∫ng 1 key.
- M·ªôt m·∫£ng byte ƒë√£ m√£ ho√°

ƒê·ªÉ parse file, m√¨nh code l·∫°i m·ªôt s·ªë h√†m c∆° b·∫£n trong Python:

- Gi·∫£i m√£ **LEB128** (c√°ch file l∆∞u ƒë·ªô d√†i)
- ƒê·ªçc string/byte array (c√≥ prefix byte ƒë√°nh d·∫•u)
- Gi·∫£i m√£ DES ECB (d√πng `pycryptodome`)

T·ªõi ƒë√¢y th√¨ b·∫°n c√≥ th·ªÉ chuy·ªÉn sang ch·∫ø ƒë·ªô vibe-coding (ho·∫∑c c√≥ th·ªÉ ngay ƒë·∫ßu c≈©ng ƒë∆∞·ª£c üêß):

```python
# parse_and_decrypt_lunadb.py
import struct, re
from io import BytesIO
from Crypto.Cipher import DES

H_START = bytes([0xFF,0x13,0x37,0xFF])
H_END   = bytes([0xFF,0xCA,0xFE,0xFF])
D_START = bytes([0xFF,0x72,0x70,0xFF])
D_END   = bytes([0xFF,0xED,0xED,0xFF])
F_START = bytes([0xFF,0xDE,0xAD,0xFF])
F_END   = bytes([0xFF,0xBE,0xEF,0xFF])

def read_leb128_u64(f):
    res = 0
    shift = 0
    while True:
        b = f.read(1)
        if not b: raise EOFError("leb128 eof")
        byte = b[0]
        res |= (byte & 0x7F) << shift
        if (byte & 0x80) == 0: break
        shift += 7
    return res

def read_string(f):
    flag = f.read(1)
    if not flag: raise EOFError("eof")
    flag = flag[0]
    if flag == 0x00: return ""
    if flag in (0x0b, 0x0c):
        ln = read_leb128_u64(f)
        return f.read(ln).decode('utf-8', errors='replace')
    raise ValueError(hex(flag))

def read_bytestring(f):
    flag = f.read(1)[0]
    if flag == 0x00: return b''
    if flag == 0x0c:
        ln = read_leb128_u64(f)
        return f.read(ln)
    raise ValueError(hex(flag))

def pkcs7_unpad(b):
    if not b: return b
    pad = b[-1]
    if pad>0 and pad<=8 and b[-pad:]==bytes([pad])*pad:
        return b[:-pad]
    return b

def decrypt_des_ecb(key, ct):
    cipher = DES.new(key, DES.MODE_ECB)
    pt = cipher.decrypt(ct)
    return pkcs7_unpad(pt)

with open("secret.lunadb","rb") as fh:
    data = fh.read()

# find sections
hs = data.find(H_START); he = data.find(H_END)
ds = data.find(D_START); de = data.find(D_END)
fs = data.find(F_START); fe = data.find(F_END)

# parse keys (8-byte each)
keys_blob = data[fs+4:fe]
keys = [keys_blob[i*8:(i+1)*8] for i in range(len(keys_blob)//8)]

# parse notes
f = BytesIO(data[ds+4:de])
flags = []
while f.tell() < len(f.getvalue()):
    if f.tell()+2 > len(f.getvalue()): break
    note_id = struct.unpack("<H", f.read(2))[0]
    access = read_string(f)
    first = read_string(f); last = read_string(f); email = read_string(f)
    title = read_string(f)
    key_field = struct.unpack("<Q", f.read(8))[0]
    enc = read_bytestring(f)
    created = struct.unpack("<Q", f.read(8))[0]
    modt = struct.unpack("<Q", f.read(8))[0]
    suspended = f.read(1)[0]
    if enc and key_field != 0xFFFFFFFFFFFFFFFF and key_field != 0:
        # only handle single-bit masks
        if (key_field & (key_field-1)) == 0:
            idx = key_field.bit_length() - 1
            if idx < len(keys):
                pt = decrypt_des_ecb(keys[idx], enc)
                try:
                    txt = pt.decode('utf-8',errors='ignore')
                except:
                    txt = ""
                if re.search(r'flag|FLAG|\{', txt, re.I):
                    print("Note id", note_id, "key idx", idx, "plaintext:", txt)
```

Sau khi ch·∫°y, ch√∫ng ta s·∫Ω thu ƒë∆∞·ª£c flag:

```
HOLACTF{4_c0Ol_Cu5t0m_f1lE_5truC7}
```

## L·ªùi k·∫øt

B√†i n√†y d√πng ChatGPT c√°i l√† ra :D

V·ªõi l·∫°i, DES/ECB v·ªën y·∫øu, n√™n l√† parse r·ªìi decrypt l√† ra h·∫π h·∫π h·∫π

Vibe/10

<img src="IMG_6239.png" alt="image.png" style="width: 30%; height: auto;" />
